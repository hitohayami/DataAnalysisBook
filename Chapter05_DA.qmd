---
title: "第5章"
format: html
editor: visual
jupyter: python3
---

```{r install_packages, include=FALSE}
local({r<-getOption("repos"); r["CRAN"] <- "https://cloud.r-project.org"; options(repos=r)})
lib_required=c("knitr","quarto","latex2exp")
id=lib_required %in% rownames(installed.packages())
install.packages(lib_required[!id],dependencies=TRUE)
for( pkg in lib_required ) library(pkg,character.only=T)
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, include=FALSE}
Cover_prob<-function(x,mu,h){
  id=which( (x-h<mu) & (mu<x+h))
  length(id)
  r=length(id)/length(x)
  return(r)
 }

Cover_graph<-function(x,mu,h){
  n_x=length(x)
  id=seq(1,n_x,1)
  Low=x-h
  High=x+h
  idx=order(x)
  x_min=min(which(Low[idx]>0.5))
  x_max=max(which(High[idx]<0.5))
  
  x_by=(n_x-1)/300
  id_x=seq(1,n_x,by=x_by)
  idx_x=idx[id_x]
  plot(id_x,x[idx_x],cex=.3,xlab="",ylab="sample mean and true value",ylim=c(0,1))
  abline(h=mu)
#  points(id,Low[idx],col="red",cex=.3)
#  points(id,High[idx],col="blue",cex=.3)
#  abline(v=x_min,lty=4,col="green")
#  abline(v=x_max,lty=4,col="green")
  points(id_x,Low[idx_x],col="black",cex=.3,pch=24)
  points(id_x,High[idx_x],col="black",cex=.3,pch=25)
  abline(v=x_min,lty=4,col="black",lwd=2)
  abline(v=x_max,lty=4,col="black",lwd=2)
 }
```

## シミュレーション1: 一様分布の平均の区間推定(分散既知)

```{r CI_Uniform}
set.seed(883)
CI_unif<-function(n){
  n_sim<-10000
  x<-vector(length=n_sim)
  ss<-vector(length=n_sim)
  for( i in c(1:n_sim)){
    U=runif(n,0,1)
    x[i]<-mean(U)
    ss[i]<-var(U)
   }
  z=data.frame(mean=x,var=ss)
  return( z )
}
Kanji="Hiragino Sans GB"
par(family=Kanji)

mu=0.5
n=5
x005<-CI_unif(n)
h=1.96*sqrt(1/(12*n))
Cover_prob(x005$mean,mu,h)
Cover_graph(x005$mean,mu,h)

hist(x005$mean,nclass=50,main="",xlab="Distribution of the sample mean n=5",freq=FALSE,xlim=c(0,1))
curve(dnorm(x,mean=mu,sd=sqrt(1/(12*n))),seq(0,1,0.02),add=TRUE,col=2)

n=15
x015<-CI_unif(n)
h=1.96*sqrt(1/(12*n))
Cover_prob(x015$mean,mu,h)
Cover_graph(x015$mean,mu,h)
hist(x015$mean,nclass=50,main="",xlab="Distribution of the sample mean n=15",freq=FALSE,xlim=c(0,1))
curve(dnorm(x,mean=mu,sd=sqrt(1/(12*n))),seq(0,1,0.02),add=TRUE,col=2)

n=25
x025<-CI_unif(n)
h=1.96*sqrt(1/(12*n))
Cover_prob(x025$mean,mu,h)
Cover_graph(x025$mean,mu,h)
hist(x025$mean,nclass=50,main="",xlab="Distribution of the sample mean n=25",freq=FALSE,xlim=c(0,1))
curve(dnorm(x,mean=mu,sd=sqrt(1/(12*n))),seq(0,1,0.02),add=TRUE,col=2)

n=100
x100<-CI_unif(n)
h=1.96*sqrt(1/(12*n))
Cover_prob(x100$mean,mu,h)
Cover_graph(x100$mean,mu,h)
hist(x100$mean,nclass=50,main="",xlab="Distribution of the sample mean n=100",freq=FALSE,xlim=c(0,1))
curve(dnorm(x,mean=mu,sd=sqrt(1/(12*n))),seq(0,1,0.02),add=TRUE,col=2)
```

## シミュレーション2: 一様分布の平均の区間推定(分散未知)

分散が未知の場合，小標本$n=5$の場合には，まったくでたらめの結果になる．

```{r CI_Uniform_var_unknown}
n=5
h=qt(0.975,df=n-1)*sqrt(x005$var/n)
Cover_prob(x005$mean,mu,h)
Cover_graph(x005$mean,mu,h)
x_std=(x005$mean-mu)/sqrt(x005$var/n)
y_max=(dt(0,df=(n-1)))
# hist(x_std,nclass=500,main="",xlab="Distribution of the standardized sample mean n=5, and t distribution df=4",freq=FALSE,xlim=c(-10,10),ylim=c(0,y_max))
hist(x_std,nclass=500,main="",xlab="Distribution of the standardized sample mean n=5, and t distribution df=4",freq=FALSE,xlim=c(-10,10))
curve(dt(x,df=(n-1)),seq(-10,10,0.02),add=TRUE,col=2)

n=15
h=qt(0.975,df=(n-1))*sqrt(x015$var/n)
Cover_prob(x015$mean,mu,h)
Cover_graph(x015$mean,mu,h)
x_std=(x015$mean-mu)/sqrt(x015$var/n)
hist(x_std,nclass=500,main="",xlab="Distribution of the standardized sample mean n=15,and t distribution df=14",freq=FALSE,xlim=c(-10,10))
curve(dt(x,df=(n-1)),seq(-10,10,0.02),add=TRUE,col=2)

n=25
h=qt(0.975,df=(n-1))*sqrt(x025$var/n)
Cover_prob(x025$mean,mu,h)
Cover_graph(x025$mean,mu,h)
x_std=(x025$mean-mu)/sqrt(x025$var/n)
hist(x_std,nclass=100,main="",xlab="Distribution of the standardized sample mean n=25,and t distribution df=24",freq=FALSE,xlim=c(-6,6))
curve(dt(x,df=(n-1)),seq(-6,6,0.02),add=TRUE,col=2)

n=100
x100<-CI_unif(n)
h=qt(0.975,df=(n-1))*sqrt(x100$var/n)
Cover_prob(x100$mean,mu,h)
Cover_graph(x100$mean,mu,h)
x_std=(x100$mean-mu)/sqrt(x100$var/n)
hist(x_std,nclass=100,main="",xlab="Distribution of the standardized sample mean n=100, and t distribution df=99",freq=FALSE,xlim=c(-4,4))
curve(dt(x,df=(n-1)),seq(-4,4,0.02),add=TRUE,col=2)
```

## シミュレーション: 指数分布が母集団分布で平均の区間推定(分散未知)

```{r CI_exponential}
set.seed(883)
CI_exp<-function(n){
  n_sim<-10000
  x<-vector(length=n_sim)
  ss<-vector(length=n_sim)
  for( i in c(1:n_sim)){
    U=rexp(n,rate=2)
    x[i]<-mean(U)
    ss[i]<-var(U)
   }
  z=data.frame(mean=x,var=ss)
  return( z )
}

n=25
x005<-CI_exp(n)
h=1.96*sqrt(mu**2/n)
Cover_prob(x005$mean,mu,h)
Cover_graph(x005$mean,mu,h)

n=5
x005<-CI_exp(n)
h=qt(.975,df=(n-1))*sqrt(x005$var/n)
Cover_prob(x005$mean,mu,h)
Cover_graph(x005$mean,mu,h)
y_max=(dt(0,df=(n-1)))
x_std=(x005$mean-mu)/sqrt(x005$var/n)
hist(x_std,nclass=2000,main="",xlab="Distribution of the standardized sample mean n=5, and t distribution",freq=FALSE,xlim=c(-10,10))
curve(dt(x,df=(n-1)),seq(-10,10,0.02),add=TRUE,col=2)

n=15
x015<-CI_exp(n)
h=qt(.975,df=(n-1))*sqrt(x015$var/n)
Cover_prob(x015$mean,mu,h)
Cover_graph(x015$mean,mu,h)
x_std=(x015$mean-mu)/sqrt(x015$var/n)
hist(x_std,nclass=1000,main="",xlab="Distribution of the standardized sample mean n=15, and t distribution",freq=FALSE,xlim=c(-10,10))
curve(dt(x,df=(n-1)),seq(-10,10,0.02),add=TRUE,col=2)

n=25
x025<-CI_exp(n)
h=qt(.975,df=(n-1))*sqrt(x025$var/n)
Cover_prob(x025$mean,mu,h)
Cover_graph(x025$mean,mu,h)
x_std=(x025$mean-mu)/sqrt(x025$var/n)
y_max=(dt(0,df=(n-1)))
hist(x_std,nclass=100,main="",xlab="Distribution of the standardized sample mean n=25, and t distribution",freq=FALSE,xlim=c(-10,10))
curve(dt(x,df=(n-1)),seq(-10,10,0.02),add=TRUE,col=2)

n=100
x100<-CI_exp(n)
h=qt(.975,df=(n-1))*sqrt(x100$var/n)
Cover_prob(x100$mean,mu,h)
Cover_graph(x100$mean,mu,h)
x_std=(x100$mean-mu)/sqrt(x100$var/n)
y_max=(dt(0,df=(n-1)))
hist(x_std,nclass=100,main="",xlab="Distribution of the standardized sample mean n=100, and t distribution",freq=FALSE,xlim=c(-4,4))
curve(dt(x,df=(n-1)),seq(-4,4,0.02),add=TRUE,col=2)
```

## シミュレーション: 割合の区間推定(Wald)

結果の図をみるとわかるように，95%の信頼区間を計算しているにもかかわらず，95%の確率で真の$p$の値が信頼区間の中に含まれることはない． 特に，0の近辺と1の近辺では精度が著しく低下している．

```{r CI_Ratio_Wald}
set.seed(883)
CI_Wald<-function(n,p){
  n_sim<-10000
  r<-vector(length=n_sim)
  for( i in 1:n_sim ){
    ph=rbinom(n,size=n,prob=p)/n
    h=1.96*sqrt(ph*(1-ph)/n)
    id=which( (ph-h<p) & (p<ph+h))
    r[i]=length(id)/length(ph)
   }
  r=data.frame(r)
  return( r )
}

Wald=vector(length=99)
i=1
for( p in seq(0.01,0.99,0.01) ){
  tmp=CI_Wald(100,p)
  Wald[i]=mean(tmp$r)
  i=i+1
 }
plot(seq(0.01,0.99,0.01),Wald,type="l",sub="Wald's Method: 95% Confidence Interval",xlab="True p",ylab="Ratio of the true p in the interval")
# abline(h=0.95,col="red")
abline(h=0.95,col="black",lty=3,lwd=3)
```

## シミュレーション: 割合の区間推定(Wilson)

結果の図をみるとわかるように，95%の信頼区間を計算しているにもかかわらず，95%以上の確率で真の$p$の値が信頼区間の中に含まれることもあるが，まだ95%以下の$p$の場合がかなりみられる．特に，0の近辺と1の近辺では精度が著しく低下している．

```{r CI_Ratio_Wilson}
set.seed(883)
CI_Wilson<-function(n,p,z){
  n_sim<-10000
  r<-vector(length=n_sim)
  for( i in 1:n_sim ){
    ph=rbinom(n,size=n,prob=p)/n
    h=1.96*sqrt(4*n*ph*(1-ph)+z^2)
    L=((2*ph*n+z^2)-h)/(2*(n+z^2)); H=((2*ph*n+z^2)+h)/(2*(n+z^2))
    id=which( (L<p) & (p<H))
    r[i]=length(id)/length(ph)
   }
  r=data.frame(r)
  return( r )
}

Wilson=vector(length=99)
i=1
for( p in seq(0.01,0.99,0.01) ){
  tmp=CI_Wilson(100,p,1.96)
  Wilson[i]=mean(tmp$r)
  i=i+1
 }
plot(seq(0.01,0.99,0.01),Wilson,type="l",sub="Wilson's Method: 95% Confidence Interval",xlab="True p",ylab="Ratio of the true p in the interval")
# abline(h=0.95,col="red")
abline(h=0.95,col="black",lty=3,lwd=3)
```

## シミュレーション: 割合の区間推定(Clopper-Pearson)

これはMac M4で2分くらい計算時間がかかる．

```{r CI_Ratio_ClopperPearson}
set.seed(883)
Sys.time()
CI_Clopper<-function(n,p){
  n_sim<-10000
  r<-vector(length=n_sim)
  for( i in 1:n_sim ){
    x=rbinom(n,size=n,prob=p)
    ph=x/n
    L=qbeta(0.025,x,n-x+1)
    H=qbeta(0.975,x+1,n-x)
    id=which( (L<p) & (p<H))
    r[i]=length(id)/length(ph)
   }
  r=data.frame(r)
  return( r )
}

Clopper=vector(length=99)
i=1
for( p in seq(0.01,0.99,0.01) ){
  tmp=CI_Clopper(100,p)
  Clopper[i]=mean(tmp$r)
  i=i+1
 }

plot(seq(0.01,0.99,0.01),Clopper,type="l",sub="Clopper-Pearson's Method: 95% Confidence Interval",xlab="True p",ylab="Ratio of the true p in the interval",ylim=c(0.85,1))
# abline(h=0.95,col="red")
abline(h=0.95,col="black",lty=3,lwd=3)
```

# Pythonのコード

## 実行に必要な準備：関数の定義

```{python}
#| label: setup0
#| echo: false
#| include: false
import importlib
import subprocess
import sys

# インストールしたいパッケージのリスト
packages_to_install  = ["matplotlib","pandas","scipy","numpy","jupyter","datetime"]

def install_if_missing(package_name):
  try:
    importlib.import_module(package_name)
    print(f"{package_name} は既にインストールされています。")
  except ImportError:
    print(f"{package_name} がインストールされていません。インストールを開始します...")
    try:
      subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
      print(f"{package_name} のインストールが完了しました。")
    except subprocess.CalledProcessError as e:
      print(f"{package_name} のインストール中にエラーが発生しました: {e}")

# 各パッケージのインストール状況を確認し、必要であればインストール
for package in packages_to_install:
  install_if_missing(package)
import datetime
```

```{python}
#| Define_generic_functions
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def Cover_prob(x, mu, h):
    id = np.where((x - h < mu) & (mu < x + h))[0]
    r = len(id) / len(x)
    return r

def Cover_graph(x, mu, h):
    id = np.arange(1, len(x) + 1, 1)
    Low = x - h
    High = x + h
    idx = np.argsort(x)
    x_min = np.min(np.where(Low[idx] > 0.5))
    x_max = np.max(np.where(High[idx] < 0.5))
    _=plt.plot(id, x[idx], 'bo', markersize=3, label="Sample mean")
    _=plt.plot(id, Low[idx], 'ro', markersize=3, label="Lower bound")
    _=plt.plot(id, High[idx], 'go', markersize=3, label="Upper bound")
    _=plt.axhline(y=mu, color='k', linestyle='-', label="True value")
    _=plt.axvline(x=x_min, color='g', linestyle='--', label="Min bound")
    _=plt.axvline(x=x_max, color='g', linestyle='--', label="Max bound")
    _=plt.xlabel("")
    _=plt.ylabel("Sample mean and true value")
    _=plt.ylim(0, 1)
    _=plt.legend()
    plt.show()
```

## シミュレーション1: 一様分布の平均の区間推定(分散既知)

```{python}
#| Uniform_known_variance
def CI_unif(n):
    np.random.seed(883)
    n_sim = 10000
    x = np.zeros(n_sim)
    ss = np.zeros(n_sim)
    for i in range(n_sim):
        U = np.random.uniform(0, 1, n)
        x[i] = np.mean(U)
        ss[i] = np.var(U)
    z = pd.DataFrame({'mean': x, 'var': ss})
    return z

mu = 0.5

n = 5
x005 = CI_unif(n)
h = 1.96 * np.sqrt(1 / (12 * n))
print(Cover_prob(x005['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x005['mean'], mu, h)

def dnorm(x,mu,n):
    ss=1/(12*n)
    return 1/np.sqrt(2*ss*np.pi)*np.exp(-(x-mu)**2/(2*ss))

plt.figure()
_=plt.hist(x005['mean'], bins=50, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(0, 1, 0.02),dnorm(np.arange(0, 1, 0.02), mu, n), color='red')
_=plt.xlabel(r"The sample mean $\mu=.5$ $n=5$")
_=plt.ylabel("Density")
_=plt.xlim(0, 1)
plt.show()

n = 15
x015 = CI_unif(n)
h = 1.96 * np.sqrt(1 / (12 * n))
print(Cover_prob(x015['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x015['mean'], mu, h)

plt.figure()
_=plt.hist(x015['mean'], bins=50, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(0, 1, 0.02),dnorm(np.arange(0, 1, 0.02), mu, n), color='red')
_=plt.xlabel(r"The sample mean $\mu=.5$ $n=15$")
_=plt.ylabel("Density")
_=plt.xlim(0, 1)
plt.show()
print(datetime.datetime.now())

n = 25
x025 = CI_unif(n)
h = 1.96 * np.sqrt(1 / (12 * n))
print(Cover_prob(x025['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x025['mean'], mu, h)

plt.figure()
_=plt.hist(x025['mean'], bins=50, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(0, 1, 0.02),dnorm(np.arange(0, 1, 0.02), mu, n), color='red')
_=plt.xlabel(r"The sample mean $\mu=.5$ $n=25$")
_=plt.ylabel("Density")
_=plt.xlim(0, 1)
plt.show()

n = 100
x100 = CI_unif(n)
h = 1.96 * np.sqrt(1 / (12 * n))
print(Cover_prob(x100['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x100['mean'], mu, h)

plt.figure()
_=plt.hist(x100['mean'], bins=50, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(0, 1, 0.02),dnorm(np.arange(0, 1, 0.02), mu, n), color='red')
_=plt.xlabel(r"The sample mean $\mu=.5$ $n=100$")
_=plt.ylabel("Density")
_=plt.xlim(0, 1)
plt.show()
```

## シミュレーション2: 一様分布の平均の区間推定(分散未知)

分散が未知の場合，小標本$n=5$の場合には，まったくでたらめの結果になる．

```{python Uniform_unknown_variance}
from scipy.stats import t

n = 5
h = t.ppf(0.975, df=n-1) * np.sqrt(x005['var'] / n)
print(Cover_prob(x005['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x005['mean'], mu, h)
x_std = (x005['mean'] - mu) / np.sqrt(x005['var'] / n)
y_max = t.pdf(0, df=n-1)

plt.figure()
_=plt.hist(x_std, bins=500, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-10, 10, 0.02), t.pdf(np.arange(-10, 10, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=5, and t distribution df=4")
_=plt.ylabel("Density")
_=plt.xlim(-10, 10)
_=plt.ylim(0, y_max)
plt.show()

n = 15
h = t.ppf(0.975, df=n-1) * np.sqrt(x015['var'] / n)
print(Cover_prob(x015['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x015['mean'], mu, h)
x_std = (x015['mean'] - mu) / np.sqrt(x015['var'] / n)

plt.figure()
_=plt.hist(x_std, bins=500, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-10, 10, 0.02), t.pdf(np.arange(-10, 10, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=15, and t distribution df=14")
_=plt.ylabel("Density")
_=plt.xlim(-10, 10)
plt.show()

n = 25
h = t.ppf(0.975, df=n-1) * np.sqrt(x025['var'] / n)
print(Cover_prob(x025['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x025['mean'], mu, h)
x_std = (x025['mean'] - mu) / np.sqrt(x025['var'] / n)

plt.figure()
_=plt.hist(x_std, bins=100, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-6, 6, 0.02), t.pdf(np.arange(-6, 6, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=25, and t distribution df=24")
_=plt.ylabel("Density")
_=plt.xlim(-6, 6)
plt.show()

n = 100
h = t.ppf(0.975, df=n-1) * np.sqrt(x100['var'] / n)
print(Cover_prob(x100['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x100['mean'], mu, h)
x_std = (x100['mean'] - mu) / np.sqrt(x100['var'] / n)

plt.figure()
_=plt.hist(x_std, bins=100, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-4, 4, 0.02), t.pdf(np.arange(-4, 4, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=100, and t distribution df=99")
_=plt.ylabel("Density")
_=plt.xlim(-4, 4)
plt.show()
```

## シミュレーション: 指数分布の平均の区間推定(分散未知)

```{python CI_exponential}
def CI_exp(n):
    np.random.seed(883)
    n_sim = 10000
    x = np.zeros(n_sim)
    ss = np.zeros(n_sim)
    for i in range(n_sim):
        U = np.random.exponential(scale=1/2, size=n)
        x[i] = np.mean(U)
        ss[i] = np.var(U)
    z = pd.DataFrame({'mean': x, 'var': ss})
    return z

n = 5
x005 = CI_exp(n)
h = t.ppf(0.975, df=n-1) * np.sqrt(x005['var'] / n)
print(Cover_prob(x005['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x005['mean'], mu, h)

x_std = (x005['mean'] - mu) / np.sqrt(x005['var'] / n)
y_max = t.pdf(0, df=n-1)
plt.figure()
_=plt.hist(x_std, bins=2000, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-10, 10, 0.02), t.pdf(np.arange(-10, 10, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=5, and t distribution")
_=plt.ylabel("Density")
_=plt.xlim(-10, 10)
plt.show()

n = 15
x015 = CI_exp(n)
h = t.ppf(0.975, df=n-1) * np.sqrt(x015['var'] / n)
print(Cover_prob(x015['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x015['mean'], mu, h)

x_std = (x015['mean'] - mu) / np.sqrt(x015['var'] / n)
y_max = t.pdf(0, df=n-1)
plt.figure()
_=plt.hist(x_std, bins=1000, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-10, 10, 0.02), t.pdf(np.arange(-10, 10, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=15, and t distribution")
_=plt.ylabel("Density")
_=plt.xlim(-10, 10)
plt.show()

n = 25
x025 = CI_exp(n)
h = t.ppf(0.975, df=n-1) * np.sqrt(x025['var'] / n)
print(Cover_prob(x025['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x025['mean'], mu, h)

x_std = (x025['mean'] - mu) / np.sqrt(x025['var'] / n)
y_max = t.pdf(0, df=n-1)
plt.figure()
_=plt.hist(x_std, bins=100, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-10, 10, 0.02), t.pdf(np.arange(-10, 10, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=25, and t distribution")
_=plt.ylabel("Density")
_=plt.xlim(-10, 10)
plt.show()

n = 100
x100 = CI_exp(n)
h = t.ppf(0.975, df=n-1) * np.sqrt(x100['var'] / n)
print(Cover_prob(x100['mean'], mu, h))

plt.close('all')
plt.figure()
Cover_graph(x100['mean'], mu, h)

x_std = (x100['mean'] - mu) / np.sqrt(x100['var'] / n)
y_max = t.pdf(0, df=n-1)
plt.figure()
_=plt.hist(x_std, bins=100, density=True, color='skyblue', alpha=0.5)
_=plt.plot(np.arange(-4, 4, 0.02), t.pdf(np.arange(-4, 4, 0.02), df=n-1), color='red')
_=plt.xlabel("The standardized sample mean n=100, and t distribution")
_=plt.ylabel("Density")
_=plt.xlim(-4, 4)
plt.show()
```

## シミュレーション: 割合の区間推定(Wald)

結果の図をみるとわかるように，95%の信頼区間を計算しているにもかかわらず，95%の確率で真の$p$の値が信頼区間の中に含まれることはない． 特に，0の近辺と1の近辺では精度が著しく低下している．

```{python CI_Ratio_Wald}
def CI_Wald(n, p):
    np.random.seed(883)
    n_sim = 10000
    r = np.zeros(n_sim)
    for i in range(n_sim):
        ph = np.random.binomial(n, p, 1) / n
        h = 1.96 * np.sqrt(ph * (1 - ph) / n)
        id = np.where((ph - h < p) & (p < ph + h))[0]
        r[i] = len(id) / len(ph)
    return r

Wald = np.zeros(99)
i = 0
for p in np.arange(0.01, 1, 0.01):
    tmp = CI_Wald(100, p)
    Wald[i] = np.mean(tmp)
    i += 1

plt.close('all')
plt.figure()
_=plt.plot(np.arange(0.01, 1, 0.01), Wald, color='blue')
_=plt.axhline(y=0.95, color='red')
_=plt.title("Wald's Method: 95% Confidence Interval")
_=plt.xlabel("True p")
_=plt.ylabel("Ratio of the true p in the interval")
plt.show()
```

## シミュレーション: 割合の区間推定(Wilson)

結果の図をみるとわかるように，95%の信頼区間を計算しているにもかかわらず，95%以上の確率で真の$p$の値が信頼区間の中に含まれることもあるが，まだ95%以下の$p$の場合がかなりみられる．特に，0の近辺と1の近辺では精度が著しく低下している．

```{python CI_Ratio_Wilson}
def CI_Wilson(n, p, z):
    np.random.seed(883)
    n_sim = 10000
    r = np.zeros(n_sim)
    for i in range(n_sim):
        ph = np.random.binomial(n, p, 1) / n
        h = 1.96 * np.sqrt(4 * n * ph * (1 - ph) + z ** 2)
        L = ((2 * ph * n + z ** 2) - h) / (2 * (n + z ** 2))
        H = ((2 * ph * n + z ** 2) + h) / (2 * (n + z ** 2))
        id = np.where((L < p) & (p < H))[0]
        r[i] = len(id) / len(ph)
    return r

Wilson = np.zeros(99)
i = 0
for p in np.arange(0.01, 1, 0.01):
    tmp = CI_Wilson(100, p, 1.96)
    Wilson[i] = np.mean(tmp)
    i += 1

plt.close('all')
plt.figure()
_=plt.plot(np.arange(0.01, 1, 0.01), Wilson, color='blue')
_=plt.axhline(y=0.95, color='red')
_=plt.title("Wilson's Method: 95% Confidence Interval")
_=plt.xlabel("True p")
_=plt.ylabel("Ratio of the true p in the interval")
plt.show()
```

## シミュレーション: 割合の区間推定(Clopper-Pearson)

```{python CI_Ratio_Wilson}
#| label: CI_Clopper_Pearson
from scipy.stats import beta

def CI_Clopper(n, p):
    np.random.seed(883)
    n_sim = 10000
    r = np.zeros(n_sim)
    for i in range(n_sim):
        x = np.random.binomial(n, p, 1)
        ph = x / n
        L = beta.ppf(0.025,x,n-x+1)
        H = beta.ppf(0.975,x,n-x+1)
        id = np.where((L < p) & (p < H))[0]
        r[i] = len(id) / len(ph)
    return r

Clopper = np.zeros(99)
i = 0
for p in np.arange(0.01, 1, 0.01):
    tmp = CI_Clopper(100, p)
    Clopper[i] = np.mean(tmp)
    i += 1

file_name="https://fs0.fbc.keio.ac.jp/~hayami/data/Clopper.npy"
Clopper = np.load(file_name)

plt.close('all')
_=plt.figure()
_=plt.plot(np.arange(0.01, 1, 0.01), Clopper, color='blue')
_=plt.axhline(y=0.95, color='red')
_=plt.title("Clopper Pearson's Method: 95% Confidence Interval")
_=plt.xlabel("True p")
_=plt.ylabel("Ratio of the true p in the interval")
plt.show()
```
